module Typeclasses

open FStar.Tactics
open FStar.Tactics.Typeclasses

(* An experiment on typeclasses using metaprogrammed arguments. *)

(*
 * The heavy lifting is done via the (dead simple) tcresolve tactics
 * which just tries to apply everything marked with the `instance` attribute
 * recursively in order to solve a goal. `Classes` have no meaning, they
 * can be any type.
 *
 * We do want some *sugar* for classes and instances, but the basic idea is here *)

(* TODO: add proofs of correctness in all classes! *)

(* A class for decidable equality *)
noeq
type deq a = {
    eq : a -> a -> bool;
}

(* Methods, should be autogenerated *)
[@tcnorm] let eq (#a:Type) [|d : deq a|] = d.eq

(* A class for additive monoids *)
noeq
type additive a = {
    zero : a;
    plus : a -> a -> a;
}

(* Methods, should be autogenerated *)
[@tcnorm] let zero (#a:Type) [|d : additive a|] = d.zero
[@tcnorm] let plus (#a:Type) [|d : additive a|] = d.plus

noeq
type num a = {
    eq_super : deq a;
    add_super : additive a;
    minus : a -> a -> a;
}
(* Methods, should be autogenerated *)
[@tcnorm] let minus (#a:Type) [|d : num a|] = d.minus

(* Superclasses! Should also be autogenerated. Note the `instance` attribute,
 * differently from the methods, since these participate in the search. *)
[@instance] let num_eq  (d : num 'a) : deq 'a = d.eq_super
[@instance] let add_num (d : num 'a) : additive 'a = d.add_super

(* A way to get `deq a` for any `a : eqtype` *)
let eq_instance_of_eqtype (#a:eqtype) : deq a =
  { eq = fun x y -> x = y }

(* Two concrete instances *)
[@instance] let eq_int : deq int  = eq_instance_of_eqtype
[@instance] let eq_bool : deq bool  = eq_instance_of_eqtype

(* A parametric instance *)
[@instance] let eq_list (eqA : deq 'a) : deq (list 'a) =
  let rec eqList (xs ys : list 'a) = match xs, ys with
  | [], [] -> true
  | x::xs, y::ys -> eq x y && eqList xs ys
  | _, _ -> false
  in
  { eq = eqList }

(* A few tests *)
let _ = assert (eq 1 1)
let _ = assert (not (eq 1 2))

let _ = assert (eq true true)
let _ = assert (not (eq true false))

// Need the assert_norm...
let _ = assert_norm (eq [1;2] [1;2])
let _ = assert_norm (not (eq [2;1] [1;2]))

(* More instances *)
[@instance]
let add_int : additive int = { zero = 0; plus = (+) }

(* Note the `solve` in the superclass, meaning we don't have to give it explicitly.
 * Anyway, we should remove the need to even write that line. *)
[@instance]
let num_int : num int =
  { eq_super  = solve;
    add_super = solve;
    minus     = (fun x y -> x - y); }

[@instance]
let add_bool : additive bool =
  { zero = false; plus = (fun x y -> x || y) }

[@instance]
let num_bool : num bool =
  { eq_super  = solve;
    add_super = solve;
    minus     = (fun x y -> x && not y) (* ?? *); }

[@instance]
let add_list #a : additive (list a) =
  { zero = []; plus = (@) }

let _ = assert (plus 1 2 = 3)
let _ = assert (plus false false = false)
let _ = assert (plus true false = true)
let _ = assert (plus [1] [2] = [1;2])

(* Up to now, that was simple overloading. Let's try some polymorphic uses *)

let rec sum (#a:Type) [|additive a|] (l : list a) : a =
    match l with
    | [] -> zero
    | x::xs -> plus x (sum xs)

let sum2 (#a:Type) [|additive a|] (l : list a) : a =
    List.Tot.fold_right plus l zero

let _ = assert_norm (sum2 [1;2;3;4] == 10)
let _ = assert_norm (sum2 [false; true] == true)

let sandwich (#a:Type) [|num a|] (x y z : a) : a =
    if eq x y
    then plus x z
    else minus y z

let test1 = assert (sum [1;2;3;4;5;6] == 21)
let test2 = assert (plus 40 (minus 10 8) == 42)
