module Eq

open FStar.Tactics.Typeclasses

(* A class for decidable equality *)
class deq a = {
  eq    : a -> a -> bool;
  eq_ok : (x:a) -> (y:a) -> Lemma (__fname__eq x y <==> x == y) // hacking a dependent record... no concrete syntax
}

(* These methods are generated by the splice *)
(* [@tcnorm] let eq_ok (#a:Type) [|d : deq a|] = d.eq_ok *)
(* [@tcnorm] let eq    (#a:Type) [|d : deq a|] = d.eq *)

(* A way to get `deq a` for any `a : eqtype` *)
let eq_instance_of_eqtype (#a:eqtype) : deq a =
  Mkdeq (fun x y -> x = y) (fun x y -> ())

(* Two concrete instances *)
[@instance] let eq_int : deq int = eq_instance_of_eqtype
[@instance] let eq_bool : deq bool = eq_instance_of_eqtype

let rec eqList [|deq 'a|] (xs ys : list 'a) : Tot (b:bool{b <==> xs == ys}) =
  match xs, ys with
  | [], [] -> true
  | x::xs, y::ys -> eq_ok x y; eq x y && eqList xs ys
  | _, _ -> false

(* A parametric instance *)
[@instance] let eq_list (eqA : deq 'a) : deq (list 'a) =
  Mkdeq eqList (fun x y -> ())

(* A few tests *)
let _ = assert (eq 1 1)
let _ = assert (not (eq 1 2))

let _ = assert (eq true true)
let _ = assert (not (eq true false))

let _ = assert (eq [1;2] [1;2])
let _ = assert (not (eq [2;1] [1;2]))
